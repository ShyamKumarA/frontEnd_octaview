{"version":3,"file":"static/js/6022.a83b9b96.chunk.js","mappings":"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","sources":["components/ComponentCard.js","../node_modules/@ucast/core/src/Condition.ts","../node_modules/@ucast/core/src/utils.ts","../node_modules/@ucast/core/src/builder.ts","../node_modules/@ucast/core/src/parsers/defaultInstructionParsers.ts","../node_modules/@ucast/core/src/parsers/ObjectQueryParser.ts","../node_modules/@ucast/core/src/interpreter.ts","../node_modules/@ucast/core/src/index.ts","../node_modules/@ucast/core/src/translator.ts","../node_modules/@ucast/mongo/src/instructions.ts","../node_modules/@ucast/mongo/src/MongoQueryParser.ts","../node_modules/@ucast/mongo/src/index.ts","../node_modules/@ucast/js/src/utils.ts","../node_modules/@ucast/js/src/interpreter.ts","../node_modules/@ucast/js/src/interpreters.ts","../node_modules/@ucast/js/src/defaults.ts","../node_modules/@ucast/mongo2js/src/factory.ts","../node_modules/@casl/ability/src/utils.ts","../node_modules/@casl/ability/src/Rule.ts","../node_modules/@casl/ability/src/structures/LinkedItem.ts","../node_modules/@casl/ability/src/RuleIndex.ts","../node_modules/@casl/ability/src/PureAbility.ts","../node_modules/@casl/ability/src/matchers/conditions.ts","../node_modules/@casl/ability/src/matchers/field.ts","../node_modules/@casl/ability/src/Ability.ts","../node_modules/@casl/ability/src/AbilityBuilder.ts","../node_modules/@casl/ability/src/ForbiddenError.ts","../node_modules/@casl/react/src/Can.ts","views/apps/accessControlCASL/AccessControl.js","../node_modules/@babel/runtime/helpers/esm/superPropBase.js","../node_modules/@babel/runtime/helpers/esm/get.js"],"sourcesContent":["import { Card, CardBody, CardTitle, CardSubtitle } from 'reactstrap';\r\nimport PropTypes from 'prop-types';\r\n\r\nconst ComponentCard = ({ children, title, subtitle }) => {\r\n  return (\r\n    <Card>\r\n      <CardTitle tag=\"h4\" className=\"border-bottom px-4 py-3 mb-0\">\r\n        {title}\r\n      </CardTitle>\r\n      <CardBody className=\"p-4\">\r\n        <CardSubtitle className=\"text-muted mb-3\">{subtitle || ''}</CardSubtitle>\r\n        <div>{children}</div>\r\n      </CardBody>\r\n    </Card>\r\n  );\r\n};\r\n\r\nComponentCard.propTypes = {\r\n  children: PropTypes.node,\r\n  title: PropTypes.string,\r\n  subtitle: PropTypes.node\r\n};\r\n\r\nexport default ComponentCard;\r\n","export interface Note<T> {\n  type: string\n  message?: string\n  originalValue?: T\n}\n\nexport abstract class Condition<T = unknown> {\n  private _notes!: Note<T>[];\n\n  constructor(\n    public readonly operator: string,\n    public readonly value: T\n  ) {\n    Object.defineProperty(this, '_notes', {\n      writable: true\n    });\n  }\n\n  get notes(): ReadonlyArray<Note<T>> | undefined {\n    return this._notes;\n  }\n\n  addNote(note: Note<T>) {\n    this._notes = this._notes || [];\n    this._notes.push(note);\n  }\n}\n\nexport class DocumentCondition<T> extends Condition<T> {\n}\n\nexport class CompoundCondition<T extends Condition = Condition> extends DocumentCondition<T[]> {\n  constructor(operator: string, conditions: T[]) {\n    if (!Array.isArray(conditions)) {\n      throw new Error(`\"${operator}\" operator expects to receive an array of conditions`);\n    }\n\n    super(operator, conditions);\n  }\n}\n\nexport const ITSELF = '__itself__';\nexport class FieldCondition<T = unknown> extends Condition<T> {\n  public readonly field!: string | typeof ITSELF;\n\n  constructor(operator: string, field: string | typeof ITSELF, value: T) {\n    super(operator, value);\n    this.field = field;\n  }\n}\n\nexport const NULL_CONDITION = new DocumentCondition('__null__', null);\nexport type ConditionValue<T> = T extends Condition<infer V> ? V : unknown;\n","import { Condition, CompoundCondition, NULL_CONDITION } from './Condition';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nexport function isCompound(operator: string, condition: Condition): condition is CompoundCondition {\n  return condition instanceof CompoundCondition && condition.operator === operator;\n}\n\nfunction flattenConditions<T extends Condition>(\n  operator: string,\n  conditions: T[],\n  aggregatedResult?: T[]\n) {\n  const flatConditions: T[] = aggregatedResult || [];\n\n  for (let i = 0, length = conditions.length; i < length; i++) {\n    const currentNode = conditions[i];\n\n    if (isCompound(operator, currentNode)) {\n      flattenConditions(operator, currentNode.value as T[], flatConditions);\n    } else {\n      flatConditions.push(currentNode);\n    }\n  }\n\n  return flatConditions;\n}\n\nexport function optimizedCompoundCondition<T extends Condition>(operator: string, conditions: T[]) {\n  if (conditions.length === 1) {\n    return conditions[0];\n  }\n\n  return new CompoundCondition(operator, flattenConditions(operator, conditions));\n}\n\nexport const identity = <T>(x: T) => x;\nexport const object = () => Object.create(null);\n\nexport const ignoreValue: IgnoreValue = Object.defineProperty(object(), '__@type@__', {\n  value: 'ignore value'\n});\nexport interface IgnoreValue {\n  readonly ['__@type@__']: 'ignore value'\n}\n\nexport function hasOperators<T>(\n  value: any,\n  instructions: Record<string, unknown>,\n  skipIgnore = false,\n): value is T {\n  if (!value || value && value.constructor !== Object) {\n    return false;\n  }\n\n  for (const prop in value) { // eslint-disable-line no-restricted-syntax, guard-for-in\n    const hasProp = hasOwnProperty(value, prop) && hasOwnProperty(instructions, prop);\n    if (hasProp && (!skipIgnore || value[prop] !== ignoreValue)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function objectKeysSkipIgnore(anyObject: Record<string, unknown>) {\n  const keys: string[] = [];\n  for (const key in anyObject) { // eslint-disable-line no-restricted-syntax\n    if (hasOwnProperty(anyObject, key) && anyObject[key] !== ignoreValue) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n}\n\nexport function pushIfNonNullCondition(conditions: Condition[], condition: Condition) {\n  if (condition !== NULL_CONDITION) {\n    conditions.push(condition);\n  }\n}\n","import { Condition } from './Condition';\nimport { optimizedCompoundCondition } from './utils';\n\nexport const buildAnd = (conditions: Condition[]) => optimizedCompoundCondition('and', conditions);\nexport const buildOr = (conditions: Condition[]) => optimizedCompoundCondition('or', conditions);\n","import {\n  FieldCondition,\n  CompoundCondition,\n  DocumentCondition,\n} from '../Condition';\nimport {\n  DocumentInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n} from '../types';\n\ninterface DefaultParsers {\n  compound: Exclude<CompoundInstruction['parse'], undefined>,\n  field: Exclude<FieldInstruction['parse'], undefined>,\n  document: Exclude<DocumentInstruction['parse'], undefined>\n}\n\nexport const defaultInstructionParsers: DefaultParsers = {\n  compound(instruction, value, context) {\n    const queries = Array.isArray(value) ? value : [value];\n    const conditions = queries.map(query => context.parse(query));\n    return new CompoundCondition(instruction.name, conditions);\n  },\n  field(instruction, value, context) {\n    return new FieldCondition(instruction.name, context.field, value);\n  },\n  document(instruction, value) {\n    return new DocumentCondition(instruction.name, value);\n  }\n};\n","import { Condition } from '../Condition';\nimport {\n  NamedInstruction,\n  ParsingInstruction,\n  FieldParsingContext,\n  ParsingContext,\n} from '../types';\nimport { buildAnd } from '../builder';\nimport { defaultInstructionParsers } from './defaultInstructionParsers';\nimport {\n  identity,\n  hasOperators,\n  object,\n  pushIfNonNullCondition,\n  objectKeysSkipIgnore,\n} from '../utils';\n\nexport type FieldQueryOperators<T extends {}> = {\n  [K in keyof T]: T[K] extends {} ? T[K] : never\n}[keyof T];\n\ntype ParsingInstructions = Record<string, NamedInstruction>;\n\nexport interface QueryOptions {\n  operatorToConditionName?(name: string): string\n  defaultOperatorName?: string\n  fieldContext?: Record<string, unknown>\n  documentContext?: Record<string, unknown>\n  useIgnoreValue?: boolean\n  mergeFinalConditions?(conditions: Condition[]): Condition\n}\n\nexport type ObjectQueryFieldParsingContext = ParsingContext<FieldParsingContext & {\n  query: {},\n  hasOperators<T>(value: unknown): value is T\n}>;\n\nexport class ObjectQueryParser<\n  T extends Record<any, any>,\n  U extends FieldQueryOperators<T> = FieldQueryOperators<T>\n> {\n  private readonly _instructions: ParsingInstructions;\n  private _fieldInstructionContext: ObjectQueryFieldParsingContext;\n  private _documentInstructionContext: ParsingContext<{ query: {} }>;\n  private readonly _options: Required<\n  Pick<QueryOptions, 'operatorToConditionName' | 'defaultOperatorName' | 'mergeFinalConditions'>\n  >;\n\n  private readonly _objectKeys: typeof Object.keys;\n\n  constructor(instructions: Record<string, ParsingInstruction>, options: QueryOptions = object()) {\n    this.parse = this.parse.bind(this);\n    this._options = {\n      operatorToConditionName: options.operatorToConditionName || identity,\n      defaultOperatorName: options.defaultOperatorName || 'eq',\n      mergeFinalConditions: options.mergeFinalConditions || buildAnd,\n    };\n    this._instructions = Object.keys(instructions).reduce((all, name) => {\n      all[name] = { name: this._options.operatorToConditionName(name), ...instructions[name] };\n      return all;\n    }, {} as ParsingInstructions);\n    this._fieldInstructionContext = {\n      ...options.fieldContext,\n      field: '',\n      query: {},\n      parse: this.parse,\n      hasOperators: <T>(value: unknown): value is T => hasOperators(\n        value,\n        this._instructions,\n        options.useIgnoreValue\n      ),\n    };\n    this._documentInstructionContext = {\n      ...options.documentContext,\n      parse: this.parse,\n      query: {}\n    };\n    this._objectKeys = options.useIgnoreValue ? objectKeysSkipIgnore : Object.keys;\n  }\n\n  setParse(parse: this['parse']) {\n    this.parse = parse;\n    this._fieldInstructionContext.parse = parse;\n    this._documentInstructionContext.parse = parse;\n  }\n\n  protected parseField(field: string, operator: string, value: unknown, parentQuery: {}) {\n    const instruction = this._instructions[operator];\n\n    if (!instruction) {\n      throw new Error(`Unsupported operator \"${operator}\"`);\n    }\n\n    if (instruction.type !== 'field') {\n      throw new Error(`Unexpected ${instruction.type} operator \"${operator}\" at field level`);\n    }\n\n    this._fieldInstructionContext.field = field;\n    this._fieldInstructionContext.query = parentQuery;\n\n    return this.parseInstruction(instruction, value, this._fieldInstructionContext);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected parseInstruction(\n    instruction: NamedInstruction,\n    value: unknown,\n    context: ParsingContext<{}>\n  ) {\n    if (typeof instruction.validate === 'function') {\n      instruction.validate(instruction, value);\n    }\n\n    const parse: typeof instruction.parse = instruction.parse\n      || defaultInstructionParsers[instruction.type as keyof typeof defaultInstructionParsers];\n    return parse(instruction, value, context);\n  }\n\n  protected parseFieldOperators(field: string, value: U) {\n    const conditions: Condition[] = [];\n    const keys = this._objectKeys(value);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const op = keys[i];\n      const instruction = this._instructions[op];\n\n      if (!instruction) {\n        throw new Error(`Field query for \"${field}\" may contain only operators or a plain object as a value`);\n      }\n\n      const condition = this.parseField(field, op, value[op as keyof U], value);\n      pushIfNonNullCondition(conditions, condition);\n    }\n\n    return conditions;\n  }\n\n  parse<Q extends T>(query: Q): Condition {\n    const conditions = [];\n    const keys = this._objectKeys(query);\n\n    this._documentInstructionContext.query = query;\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      const value = query[key];\n      const instruction = this._instructions[key];\n\n      if (instruction) {\n        if (instruction.type !== 'document' && instruction.type !== 'compound') {\n          throw new Error(`Cannot use parsing instruction for operator \"${key}\" in \"document\" context as it is supposed to be used in  \"${instruction.type}\" context`);\n        }\n\n        pushIfNonNullCondition(\n          conditions,\n          this.parseInstruction(instruction, value, this._documentInstructionContext)\n        );\n      } else if (this._fieldInstructionContext.hasOperators<U>(value)) {\n        conditions.push(...this.parseFieldOperators(key, value));\n      } else {\n        pushIfNonNullCondition(\n          conditions,\n          this.parseField(key, this._options.defaultOperatorName, value, query)\n        );\n      }\n    }\n\n    return this._options.mergeFinalConditions(conditions);\n  }\n}\n","import { Condition } from './Condition';\n\ntype ArgsExceptLast<F extends (...args: any[]) => any> =\n  F extends (a: any, c: any) => any\n    ? Parameters<(condition: Condition) => 0>\n    : F extends (a: any, b: any, c: any) => any\n      ? Parameters<(condition: Condition, value: Parameters<F>[1]) => 0>\n      : Parameters<(\n        condition: Condition,\n        value: Parameters<F>[1],\n        options: Parameters<F>[2],\n        ...args: unknown[]\n      ) => 0>;\n\nexport type Interpreter<T extends Condition, R> = (condition: T, ...args: any[]) => R;\nexport type AnyInterpreter = Interpreter<any, any>;\nexport interface InterpretationContext<T extends AnyInterpreter> {\n  interpret(...args: ArgsExceptLast<T>): ReturnType<T>;\n}\n\nfunction getInterpreter<T extends Record<string, AnyInterpreter>>(\n  interpreters: T,\n  operator: keyof T\n) {\n  const interpret = interpreters[operator];\n\n  if (typeof interpret !== 'function') {\n    throw new Error(`Unable to interpret \"${operator}\" condition. Did you forget to register interpreter for it?`);\n  }\n\n  return interpret;\n}\n\nexport interface InterpreterOptions {\n  numberOfArguments?: 1 | 2 | 3\n  getInterpreterName?(condition: Condition, context: this): string\n}\n\nfunction defaultInterpreterName(condition: Condition) {\n  return condition.operator;\n}\n\nexport function createInterpreter<T extends AnyInterpreter, U extends {} = {}>(\n  interpreters: Record<string, T>,\n  rawOptions?: U\n) {\n  const options = rawOptions as U & InterpreterOptions;\n  const getInterpreterName = options && options.getInterpreterName || defaultInterpreterName;\n  let interpret;\n\n  switch (options ? options.numberOfArguments : 0) {\n    case 1:\n      interpret = ((condition) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    case 3:\n      interpret = ((condition, value, params) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, params, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    default:\n      interpret = ((condition, value) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n  }\n\n  const defaultContext = {\n    ...options,\n    interpret,\n  } as InterpretationContext<T> & U;\n\n  return defaultContext.interpret;\n}\n","import { ObjectQueryParser } from './parsers/ObjectQueryParser';\n\nexport * from './Condition';\nexport * from './types';\nexport * from './interpreter';\nexport * from './translator';\nexport * from './builder';\nexport {\n  isCompound,\n  hasOperators,\n  identity,\n  object,\n  optimizedCompoundCondition,\n  ignoreValue,\n} from './utils';\nexport type {\n  IgnoreValue\n} from './utils';\nexport * from './parsers/ObjectQueryParser';\nexport * from './parsers/defaultInstructionParsers';\n/**\n * @deprecated use `ObjectQueryParser#parseInstruction` instead\n * TODO(major): remove\n */\nexport const parseInstruction = (ObjectQueryParser.prototype as any).parseInstruction;\n","import { Condition } from './Condition';\nimport { Parse } from './types';\nimport { AnyInterpreter } from './interpreter';\n\ntype Bound<T> = T extends (first: Condition, ...args: infer A) => any\n  ? { (...args: A): ReturnType<T>, ast: Condition }\n  : never;\n\nexport function createTranslatorFactory<Lang, Interpreter extends AnyInterpreter>(\n  parse: Parse<Lang>,\n  interpret: Interpreter\n) {\n  return (query: Lang, ...args: unknown[]): Bound<Interpreter> => {\n    const ast = parse(query, ...args);\n    const translate = (interpret as any).bind(null, ast);\n    translate.ast = ast;\n    return translate;\n  };\n}\n","import {\n  CompoundCondition,\n  FieldCondition,\n  NamedInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n  DocumentInstruction,\n  Comparable,\n  ITSELF,\n  NULL_CONDITION,\n  FieldParsingContext,\n  optimizedCompoundCondition,\n  ObjectQueryFieldParsingContext,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nfunction ensureIsArray(instruction: NamedInstruction, value: unknown) {\n  if (!Array.isArray(value)) {\n    throw new Error(`\"${instruction.name}\" expects value to be an array`);\n  }\n}\n\nfunction ensureIsNonEmptyArray(instruction: NamedInstruction, value: unknown[]) {\n  ensureIsArray(instruction, value);\n\n  if (!value.length) {\n    throw new Error(`\"${instruction.name}\" expects to have at least one element in array`);\n  }\n}\n\nfunction ensureIsComparable(instruction: NamedInstruction, value: string | number | Date) {\n  const isComparable = typeof value === 'string' || typeof value === 'number' || value instanceof Date;\n\n  if (!isComparable) {\n    throw new Error(`\"${instruction.name}\" expects value to be comparable (i.e., string, number or date)`);\n  }\n}\n\nconst ensureIs = (type: string) => (instruction: NamedInstruction, value: unknown) => {\n  if (typeof value !== type) { // eslint-disable-line valid-typeof\n    throw new Error(`\"${instruction.name}\" expects value to be a \"${type}\"`);\n  }\n};\n\nexport const $and: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n  parse(instruction, queries, { parse }) {\n    const conditions = queries.map(query => parse(query));\n    return optimizedCompoundCondition(instruction.name, conditions);\n  }\n};\nexport const $or = $and;\nexport const $nor: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n};\n\nexport const $not: FieldInstruction<MongoQuery<any> | RegExp> = {\n  type: 'field',\n  validate(instruction, value) {\n    const isValid = value && (value instanceof RegExp || value.constructor === Object);\n\n    if (!isValid) {\n      throw new Error(`\"${instruction.name}\" expects to receive either regular expression or object of field operators`);\n    }\n  },\n  parse(instruction, value, context) {\n    const condition = value instanceof RegExp\n      ? new FieldCondition('regex' as typeof instruction.name, context.field, value)\n      : context.parse(value, context);\n\n    return new CompoundCondition(instruction.name, [condition]);\n  },\n};\nexport const $elemMatch: FieldInstruction<MongoQuery<any>, ObjectQueryFieldParsingContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!value || value.constructor !== Object) {\n      throw new Error(`\"${instruction.name}\" expects to receive an object with nested query or field level operators`);\n    }\n  },\n  parse(instruction, value, { parse, field, hasOperators }) {\n    const condition = hasOperators(value) ? parse(value, { field: ITSELF }) : parse(value);\n    return new FieldCondition(instruction.name, field, condition);\n  }\n};\n\nexport const $size: FieldInstruction<number> = {\n  type: 'field',\n  validate: ensureIs('number')\n};\nexport const $in: FieldInstruction<unknown[]> = {\n  type: 'field',\n  validate: ensureIsArray,\n};\nexport const $nin = $in;\nexport const $all = $in;\nexport const $mod: FieldInstruction<[number, number]> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!Array.isArray(value) || value.length !== 2) {\n      throw new Error(`\"${instruction.name}\" expects an array with 2 numeric elements`);\n    }\n  }\n};\n\nexport const $exists: FieldInstruction<boolean> = {\n  type: 'field',\n  validate: ensureIs('boolean'),\n};\n\nexport const $gte: FieldInstruction<Comparable> = {\n  type: 'field',\n  validate: ensureIsComparable\n};\nexport const $gt = $gte;\nexport const $lt = $gt;\nexport const $lte = $gt;\n\nexport const $eq: FieldInstruction = {\n  type: 'field',\n};\nexport const $ne = $eq;\n\nexport interface RegExpFieldContext extends FieldParsingContext {\n  query: {\n    $options?: string\n  }\n}\n\nexport const $regex: FieldInstruction<string | RegExp, RegExpFieldContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!(value instanceof RegExp) && typeof value !== 'string') {\n      throw new Error(`\"${instruction.name}\" expects value to be a regular expression or a string that represents regular expression`);\n    }\n  },\n  parse(instruction, rawValue, context) {\n    const value = typeof rawValue === 'string'\n      ? new RegExp(rawValue, context.query.$options || '')\n      : rawValue;\n    return new FieldCondition(instruction.name, context.field, value);\n  }\n};\nexport const $options: FieldInstruction = {\n  type: 'field',\n  parse: () => NULL_CONDITION,\n};\n\nexport const $where: DocumentInstruction<() => boolean> = {\n  type: 'document',\n  validate: ensureIs('function'),\n};\n","import {\n  Condition,\n  buildAnd as and,\n  ParsingInstruction,\n  ObjectQueryParser,\n  FieldQueryOperators,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nexport interface ParseOptions {\n  field: string\n}\n\nexport class MongoQueryParser extends ObjectQueryParser<MongoQuery<any>> {\n  constructor(instructions: Record<string, ParsingInstruction>) {\n    super(instructions, {\n      defaultOperatorName: '$eq',\n      operatorToConditionName: name => name.slice(1),\n    });\n  }\n\n  parse<Q extends MongoQuery<any>, FQ extends FieldQueryOperators<Q> = FieldQueryOperators<Q>>(\n    query: Q | FQ,\n    options?: ParseOptions\n  ): Condition {\n    if (options && options.field) {\n      return and(this.parseFieldOperators(options.field, query as FQ));\n    }\n\n    return super.parse(query);\n  }\n}\n","import * as instructions from './instructions';\n\nexport const allParsingInstructions = instructions;\nexport * from './instructions';\nexport * from './MongoQueryParser';\nexport * from './types';\nexport { defaultInstructionParsers as defaultParsers } from '@ucast/core';\n","import { FieldCondition } from '@ucast/core';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nexport type AnyObject = Record<PropertyKey, unknown>;\nexport type GetField = (object: any, field: string) => any;\n\nexport function includes<T>(\n  items: T[],\n  value: T,\n  compare: JsInterpretationOptions['compare']\n): boolean {\n  for (let i = 0, length = items.length; i < length; i++) {\n    if (compare(items[i], value) === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isArrayAndNotNumericField<T>(object: T | T[], field: string): object is T[] {\n  return Array.isArray(object) && Number.isNaN(Number(field));\n}\n\nfunction getField<T extends AnyObject>(object: T | T[], field: string, get: GetField) {\n  if (!isArrayAndNotNumericField(object, field)) {\n    return get(object, field);\n  }\n\n  let result: unknown[] = [];\n\n  for (let i = 0; i < object.length; i++) {\n    const value = get(object[i], field);\n    if (typeof value !== 'undefined') {\n      result = result.concat(value);\n    }\n  }\n\n  return result;\n}\n\nexport function getValueByPath(object: AnyObject, field: string, get: GetField) {\n  if (field.indexOf('.') === -1) {\n    return getField(object, field, get);\n  }\n\n  const paths = field.split('.');\n  let value = object;\n\n  for (let i = 0, length = paths.length; i < length; i++) {\n    value = getField(value, paths[i], get);\n\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n  }\n\n  return value;\n}\n\nexport function testValueOrArray<T, U = T>(test: JsInterpreter<FieldCondition<T>, U>) {\n  return ((node, object, context) => {\n    const value = context.get(object, node.field);\n\n    if (!Array.isArray(value)) {\n      return test(node, value, context);\n    }\n\n    return value.some(v => test(node, v, context));\n  }) as JsInterpreter<FieldCondition<T>, AnyObject | U>;\n}\n","import { createInterpreter, ITSELF } from '@ucast/core';\nimport { getValueByPath, AnyObject, GetField } from './utils';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nconst defaultGet = (object: AnyObject, field: string) => object[field];\ntype Field = string | typeof ITSELF;\n\nexport function getObjectFieldCursor<T extends {}>(object: T, path: string, get: GetField) {\n  const dotIndex = path.lastIndexOf('.');\n\n  if (dotIndex === -1) {\n    return [object, path] as const;\n  }\n\n  return [\n    get(object, path.slice(0, dotIndex)) as T,\n    path.slice(dotIndex + 1)\n  ] as const;\n}\n\nexport function getObjectField(object: unknown, field: Field, get: GetField = defaultGet) {\n  if (field === ITSELF) {\n    return object;\n  }\n\n  if (!object) {\n    throw new Error(`Unable to get field \"${field}\" out of ${String(object)}.`);\n  }\n\n  return getValueByPath(object as Record<string, unknown>, field, get);\n}\n\nexport function createGetter<T extends GetField>(get: T) {\n  return (object: Parameters<T>[0], field: Parameters<T>[1]) => getObjectField(object, field, get);\n}\n\nexport function compare<T>(a: T, b: T): 0 | 1 | -1 {\n  if (a === b) {\n    return 0;\n  }\n\n  return a > b ? 1 : -1;\n}\n\nexport function createJsInterpreter<\n  T extends JsInterpreter<any>,\n  O extends Partial<JsInterpretationOptions>\n>(\n  operators: Record<string, T>,\n  options: O = {} as O\n) {\n  return createInterpreter(operators, {\n    get: getObjectField,\n    compare,\n    ...options,\n  });\n}\n","import {\n  CompoundCondition as Compound,\n  FieldCondition as Field,\n  DocumentCondition as Document,\n  Condition,\n  Comparable,\n  ITSELF,\n} from '@ucast/core';\nimport { JsInterpreter as Interpret } from './types';\nimport {\n  includes,\n  testValueOrArray,\n  isArrayAndNotNumericField,\n  AnyObject,\n} from './utils';\nimport { getObjectFieldCursor } from './interpreter';\n\nexport const or: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.some(condition => interpret(condition, object));\n};\n\nexport const nor: typeof or = (node, object, context) => {\n  return !or(node, object, context);\n};\n\nexport const and: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.every(condition => interpret(condition, object));\n};\n\nexport const not: Interpret<Compound> = (node, object, { interpret }) => {\n  return !interpret(node.value[0], object);\n};\n\nexport const eq: Interpret<Field> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n\n  if (Array.isArray(value) && !Array.isArray(node.value)) {\n    return includes(value, node.value, compare);\n  }\n\n  return compare(value, node.value) === 0;\n};\n\nexport const ne: typeof eq = (node, object, context) => {\n  return !eq(node, object, context);\n};\n\nexport const lte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === -1;\n});\n\nexport const lt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === -1;\n});\nexport const gt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === 1;\n});\nexport const gte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === 1;\n});\n\nexport const exists: Interpret<Field<boolean>> = (node, object, { get }) => {\n  if (node.field === ITSELF) {\n    return typeof object !== 'undefined';\n  }\n\n  const [item, field] = getObjectFieldCursor<{}>(object, node.field, get);\n  const test = (value: {}) => !!value && value.hasOwnProperty(field) === node.value;\n\n  return isArrayAndNotNumericField(item, field) ? item.some(test) : test(item);\n};\n\nexport const mod = testValueOrArray<[number, number], number>((node, value) => {\n  return typeof value === 'number' && value % node.value[0] === node.value[1];\n});\n\nexport const size: Interpret<Field<number>, AnyObject | unknown[]> = (node, object, { get }) => {\n  const [items, field] = getObjectFieldCursor(object as AnyObject, node.field, get);\n  const test = (item: unknown) => {\n    const value = get(item, field);\n    return Array.isArray(value) && value.length === node.value;\n  };\n\n  return node.field !== ITSELF && isArrayAndNotNumericField(items, field)\n    ? items.some(test)\n    : test(items);\n};\n\nexport const regex = testValueOrArray<RegExp, string>((node, value) => {\n  return typeof value === 'string' && node.value.test(value);\n});\n\nexport const within = testValueOrArray<unknown[], unknown>((node, object, { compare }) => {\n  return includes(node.value, object, compare);\n});\n\nexport const nin: typeof within = (node, object, context) => !within(node, object, context);\n\nexport const all: Interpret<Field<unknown[]>> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && node.value.every(v => includes(value, v, compare));\n};\n\nexport const elemMatch: Interpret<Field<Condition>> = (node, object, { interpret, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && value.some(v => interpret(node.value, v));\n};\n\ntype WhereFunction = (this: AnyObject) => boolean;\nexport const where: Interpret<Document<WhereFunction>, AnyObject> = (node, object) => {\n  return node.value.call(object);\n};\n","import { createJsInterpreter } from './interpreter';\nimport * as interpreters from './interpreters';\n\nexport const allInterpreters = {\n  ...interpreters,\n  in: interpreters.within,\n};\nexport const interpret = createJsInterpreter(allInterpreters);\n","import { createTranslatorFactory, ParsingInstruction, Condition, ITSELF } from '@ucast/core';\nimport {\n  MongoQuery,\n  MongoQueryParser,\n  MongoQueryFieldOperators,\n  allParsingInstructions,\n  defaultParsers\n} from '@ucast/mongo';\nimport {\n  createJsInterpreter,\n  allInterpreters,\n  JsInterpreter,\n  JsInterpretationOptions,\n  compare\n} from '@ucast/js';\n\ntype ThingFilter<T> = {\n  (object: T): boolean\n  ast: Condition\n};\n\ninterface HasToJSON {\n  toJSON(): unknown\n}\n\nfunction toPrimitive(value: unknown) {\n  if (value instanceof Date) {\n    return value.getTime();\n  }\n\n  if (value && typeof (value as HasToJSON).toJSON === 'function') {\n    return (value as HasToJSON).toJSON();\n  }\n\n  return value;\n}\n\nconst comparePrimitives: typeof compare = (a, b) => compare(toPrimitive(a), toPrimitive(b));\n\nexport interface FactoryOptions extends JsInterpretationOptions {\n  forPrimitives: boolean\n}\n\nexport type Filter = <\n  T = Record<string, unknown>,\n  Q extends MongoQuery<T> = MongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\nexport type PrimitiveMongoQuery<T> = MongoQueryFieldOperators<T> & Partial<{\n  $and: MongoQueryFieldOperators<T>[],\n  $or: MongoQueryFieldOperators<T>[],\n  $nor: MongoQueryFieldOperators<T>[]\n}>;\nexport type PrimitiveFilter = <\n  T,\n  Q extends PrimitiveMongoQuery<T> = PrimitiveMongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\ntype FilterType<T extends { forPrimitives?: true }> = T['forPrimitives'] extends true\n  ? PrimitiveFilter\n  : Filter;\n\nexport function createFactory<\n  T extends Record<string, ParsingInstruction<any, any>>,\n  I extends Record<string, JsInterpreter<any>>,\n  P extends { forPrimitives?: true }\n>(instructions: T, interpreters: I, options?: Partial<FactoryOptions> & P): FilterType<P> {\n  const parser = new MongoQueryParser(instructions);\n  const interpret = createJsInterpreter(interpreters, {\n    compare: comparePrimitives,\n    ...options\n  });\n\n  if (options && options.forPrimitives) {\n    const params = { field: ITSELF };\n    const parse = parser.parse;\n    parser.setParse(query => parse(query, params));\n  }\n\n  return createTranslatorFactory(parser.parse, interpret) as any;\n}\n\nexport const guard = createFactory(allParsingInstructions, allInterpreters);\n\nconst compoundOperators = ['$and', '$or'] as const;\nconst allPrimitiveParsingInstructions = compoundOperators.reduce((instructions, name) => {\n  instructions[name] = { ...instructions[name], type: 'field' } as any;\n  return instructions;\n}, {\n  ...allParsingInstructions,\n  $nor: {\n    ...allParsingInstructions.$nor,\n    type: 'field',\n    parse: defaultParsers.compound\n  }\n});\n\nexport const squire = createFactory(allPrimitiveParsingInstructions, allInterpreters, {\n  forPrimitives: true\n});\nexport const filter = guard; // TODO: remove in next major version\n","import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport const getSubjectTypeName = (value: SubjectType) => {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n};\n\nexport function detectSubjectType(subject: Exclude<Subject, SubjectType>): string {\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(subject.constructor as SubjectClass);\n}\n\ntype AliasMerge = (actions: string[], action: string | string[]) => string[];\nfunction expandActions(aliasMap: AliasesMap, rawActions: string | string[], merge: AliasMerge) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = merge(actions, aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction findDuplicate(actions: string[], actionToFind: string | string[]) {\n  if (typeof actionToFind === 'string' && actions.indexOf(actionToFind) !== -1) {\n    return actionToFind;\n  }\n\n  for (let i = 0; i < actionToFind.length; i++) {\n    if (actions.indexOf(actionToFind[i]) !== -1) return actionToFind[i];\n  }\n\n  return null;\n}\n\nconst defaultAliasMerge: AliasMerge = (actions, action) => actions.concat(action);\nfunction validateForCycles(aliasMap: AliasesMap, reservedAction: string) {\n  if (reservedAction in aliasMap) {\n    throw new Error(`Cannot use \"${reservedAction}\" as an alias because it's reserved action.`);\n  }\n\n  const keys = Object.keys(aliasMap);\n  const mergeAliasesAndDetectCycles: AliasMerge = (actions, action) => {\n    const duplicate = findDuplicate(actions, action);\n    if (duplicate) throw new Error(`Detected cycle ${duplicate} -> ${actions.join(', ')}`);\n\n    const isUsingReservedAction = typeof action === 'string' && action === reservedAction\n      || actions.indexOf(reservedAction) !== -1\n      || Array.isArray(action) && action.indexOf(reservedAction) !== -1;\n    if (isUsingReservedAction) throw new Error(`Cannot make an alias to \"${reservedAction}\" because this is reserved action`);\n\n    return actions.concat(action);\n  };\n\n  for (let i = 0; i < keys.length; i++) {\n    expandActions(aliasMap, keys[i], mergeAliasesAndDetectCycles);\n  }\n}\n\nexport type AliasResolverOptions = { skipValidate?: boolean; anyAction?: string };\nexport function createAliasResolver(aliasMap: AliasesMap, options?: AliasResolverOptions) {\n  if (!options || options.skipValidate !== false) {\n    validateForCycles(aliasMap, options && options.anyAction || 'manage');\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action, defaultAliasMerge);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n","import { wrapArray, isSubjectType } from './utils';\nimport {\n  MatchConditions,\n  MatchField,\n  Abilities,\n  ToAbilityTypes,\n  Normalize,\n  ConditionsMatcher,\n  FieldMatcher,\n} from './types';\nimport { RawRule, RawRuleFrom } from './RawRule';\n\ntype Tuple<A extends Abilities> = Normalize<ToAbilityTypes<A>>;\n\nfunction validate(rule: RawRuleFrom<Abilities, any>, options: RuleOptions<any>) {\n  if (Array.isArray(rule.fields) && !rule.fields.length) {\n    throw new Error('`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa');\n  }\n\n  if (rule.fields && !options.fieldMatcher) {\n    throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  }\n\n  if (rule.conditions && !options.conditionsMatcher) {\n    throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n  }\n}\n\nexport interface RuleOptions<Conditions> {\n  conditionsMatcher?: ConditionsMatcher<Conditions>\n  fieldMatcher?: FieldMatcher\n  resolveAction(action: string | string[]): string | string[]\n}\n\nexport class Rule<A extends Abilities, C> {\n  private _matchConditions: MatchConditions | undefined;\n  private _matchField: MatchField<string> | undefined;\n  private readonly _options!: RuleOptions<C>;\n  public readonly action!: Tuple<A>[0] | Tuple<A>[0][];\n  public readonly subject!: Tuple<A>[1] | Tuple<A>[1][];\n  public readonly inverted!: boolean;\n  public readonly conditions!: C | undefined;\n  public readonly fields!: string[] | undefined;\n  public readonly reason!: string | undefined;\n  public readonly priority!: number;\n\n  constructor(\n    rule: RawRule<ToAbilityTypes<A>, C>,\n    options: RuleOptions<C>,\n    priority: number = 0\n  ) {\n    validate(rule, options);\n\n    this.action = options.resolveAction(rule.action);\n    this.subject = rule.subject!;\n    this.inverted = !!rule.inverted;\n    this.conditions = rule.conditions;\n    this.reason = rule.reason;\n    this.fields = rule.fields ? wrapArray(rule.fields) : undefined;\n    this.priority = priority;\n    this._options = options;\n  }\n\n  private _conditionsMatcher() {\n    if (this.conditions && !this._matchConditions) {\n      this._matchConditions = this._options.conditionsMatcher!(this.conditions);\n    }\n\n    return this._matchConditions!;\n  }\n\n  get ast() {\n    const matches = this._conditionsMatcher();\n    return matches ? matches.ast : undefined;\n  }\n\n  matchesConditions(object: Normalize<A>[1] | undefined): boolean {\n    if (!this.conditions) {\n      return true;\n    }\n\n    if (!object || isSubjectType(object)) {\n      return !this.inverted;\n    }\n\n    const matches = this._conditionsMatcher();\n    return matches(object as Record<string, unknown>);\n  }\n\n  matchesField(field: string | undefined): boolean {\n    if (!this.fields) {\n      return true;\n    }\n\n    if (!field) {\n      return !this.inverted;\n    }\n\n    if (this.fields && !this._matchField) {\n      this._matchField = this._options.fieldMatcher!(this.fields);\n    }\n\n    return this._matchField!(field);\n  }\n}\n","export interface LinkedItem<T> {\n  next: LinkedItem<T> | null\n  prev: LinkedItem<T> | null\n  readonly value: T\n}\n\nexport function linkedItem<T>(value: T, prev: LinkedItem<T>['prev']) {\n  const item = { value, prev, next: null };\n\n  if (prev) {\n    prev.next = item;\n  }\n\n  return item;\n}\n\nexport function unlinkItem(item: LinkedItem<any>) {\n  if (item.next) {\n    item.next.prev = item.prev;\n  }\n\n  if (item.prev) {\n    item.prev.next = item.next;\n  }\n\n  item.next = item.prev = null; // eslint-disable-line\n}\n\nexport const cloneLinkedItem = <T extends LinkedItem<any>>(item: T): T => ({\n  value: item.value,\n  prev: item.prev,\n  next: item.next,\n} as T);\n","import { Rule, RuleOptions } from './Rule';\nimport { RawRuleFrom } from './RawRule';\nimport {\n  Abilities,\n  Normalize,\n  SubjectType,\n  AbilityParameters,\n  AbilityTuple,\n  ExtractSubjectType\n} from './types';\nimport { wrapArray, detectSubjectType, mergePrioritized, getOrDefault, identity, isSubjectType } from './utils';\nimport { LinkedItem, linkedItem, unlinkItem, cloneLinkedItem } from './structures/LinkedItem';\n\nexport interface RuleIndexOptions<A extends Abilities, C> extends Partial<RuleOptions<C>> {\n  detectSubjectType?(\n    subject: Exclude<Normalize<A>[1], SubjectType>\n  ): ExtractSubjectType<Normalize<A>[1]>;\n  anyAction?: string;\n  anySubjectType?: string;\n}\n\ndeclare const $abilities: unique symbol;\ndeclare const $conditions: unique symbol;\ninterface WithGenerics {\n  [$abilities]: any\n  [$conditions]: any\n}\nexport type Public<T extends WithGenerics> = { [K in keyof T]: T[K] };\nexport interface Generics<T extends WithGenerics> {\n  abilities: T[typeof $abilities],\n  conditions: T[typeof $conditions]\n}\n\nexport type RuleOf<T extends WithGenerics> =\n  Rule<Generics<T>['abilities'], Generics<T>['conditions']>;\nexport type RawRuleOf<T extends WithGenerics> =\n  RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport type RuleIndexOptionsOf<T extends WithGenerics> =\n  RuleIndexOptions<Generics<T>['abilities'], Generics<T>['conditions']>;\n\ninterface AbilityEvent<T extends WithGenerics> {\n  target: T\n  /** @deprecated use \"target\" property instead */\n  ability: T\n}\n\nexport interface UpdateEvent<T extends WithGenerics> extends AbilityEvent<T> {\n  rules: RawRuleOf<T>[]\n}\n/**\n * @deprecated `on`/`emit` properly infer type without this type\n * TODO(major): delete\n */\nexport type EventHandler<Event> = (event: Event) => void;\n\nexport type Events<\n  T extends WithGenerics,\n  K extends keyof EventsMap<T> = keyof EventsMap<T>\n> = Map<K, LinkedItem<EventsMap<T>[K]> | null>;\n\ninterface EventsMap<T extends WithGenerics> {\n  update(event: UpdateEvent<T>): void\n  updated(event: UpdateEvent<T>): void\n}\n\ntype IndexTree<A extends Abilities, C> = Map<SubjectType, Map<string, {\n  rules: Rule<A, C>[],\n  merged: boolean\n}>>;\n\nexport type Unsubscribe = () => void;\n\nconst defaultActionEntry = () => ({\n  rules: [] as unknown as Rule<any, any>[],\n  merged: false\n});\nconst defaultSubjectEntry = () => new Map<string, ReturnType<typeof defaultActionEntry>>();\nconst analyze = (index: any, rule: Rule<any, any>) => {\n  if (!index._hasPerFieldRules && rule.fields) {\n    index._hasPerFieldRules = true;\n  }\n};\n\ntype AbilitySubjectTypeParameters<T extends Abilities, IncludeField extends boolean = true> =\n  AbilityParameters<\n  T,\n  T extends AbilityTuple\n    ? IncludeField extends true\n      ? (action: T[0], subject: ExtractSubjectType<T[1]>, field?: string) => 0\n      : (action: T[0], subject: ExtractSubjectType<T[1]>) => 0\n    : never,\n  (action: Extract<T, string>) => 0\n  >;\n\nexport class RuleIndex<A extends Abilities, Conditions> {\n  private _hasPerFieldRules: boolean = false;\n  private _events: Events<this> = new Map();\n  private _indexedRules!: IndexTree<A, Conditions>;\n  private _rules!: RawRuleFrom<A, Conditions>[];\n  private readonly _ruleOptions!: RuleOptions<Conditions>;\n  private readonly _detectSubjectType!: Required<RuleIndexOptions<A, Conditions>>['detectSubjectType'];\n  private readonly _anyAction: string;\n  private readonly _anySubjectType: string;\n  readonly [$abilities]!: A;\n  readonly [$conditions]!: Conditions;\n\n  constructor(\n    rules: RawRuleFrom<A, Conditions>[] = [],\n    options: RuleIndexOptions<A, Conditions> = {}\n  ) {\n    this._ruleOptions = {\n      conditionsMatcher: options.conditionsMatcher,\n      fieldMatcher: options.fieldMatcher,\n      resolveAction: options.resolveAction || identity,\n    };\n    this._anyAction = options.anyAction || 'manage';\n    this._anySubjectType = options.anySubjectType || 'all';\n    this._detectSubjectType = options.detectSubjectType || detectSubjectType;\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n  }\n\n  get rules() {\n    return this._rules;\n  }\n\n  detectSubjectType(object?: Normalize<A>[1]): ExtractSubjectType<Normalize<A>[1]> {\n    if (isSubjectType(object)) return object;\n    if (!object) return this._anySubjectType;\n    return this._detectSubjectType(object as Exclude<Normalize<A>[1], SubjectType>);\n  }\n\n  update(rules: RawRuleFrom<A, Conditions>[]): Public<this> {\n    const event = {\n      rules,\n      ability: this,\n      target: this\n    } as unknown as UpdateEvent<this>;\n\n    this._emit('update', event);\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n    this._emit('updated', event);\n\n    return this;\n  }\n\n  private _buildIndexFor(rawRules: RawRuleFrom<A, Conditions>[]) {\n    const indexedRules: IndexTree<A, Conditions> = new Map();\n\n    for (let i = rawRules.length - 1; i >= 0; i--) {\n      const priority = rawRules.length - i - 1;\n      const rule = new Rule(rawRules[i], this._ruleOptions, priority);\n      const actions = wrapArray(rule.action);\n      const subjects = wrapArray(rule.subject || this._anySubjectType);\n      analyze(this, rule);\n\n      for (let k = 0; k < subjects.length; k++) {\n        const subjectRules = getOrDefault(indexedRules, subjects[k], defaultSubjectEntry);\n\n        for (let j = 0; j < actions.length; j++) {\n          getOrDefault(subjectRules, actions[j], defaultActionEntry).rules.push(rule);\n        }\n      }\n    }\n\n    return indexedRules;\n  }\n\n  possibleRulesFor(...args: AbilitySubjectTypeParameters<A, false>): Rule<A, Conditions>[]\n  possibleRulesFor(\n    action: string,\n    subjectType: SubjectType = this._anySubjectType\n  ): Rule<A, Conditions>[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    }\n\n    const subjectRules = getOrDefault(this._indexedRules, subjectType, defaultSubjectEntry);\n    const actionRules = getOrDefault(subjectRules, action, defaultActionEntry);\n\n    if (actionRules.merged) {\n      return actionRules.rules;\n    }\n\n    const anyActionRules = action !== this._anyAction && subjectRules.has(this._anyAction)\n      ? subjectRules.get(this._anyAction)!.rules\n      : undefined;\n    let rules = mergePrioritized(actionRules.rules, anyActionRules);\n\n    if (subjectType !== this._anySubjectType) {\n      rules = mergePrioritized(rules, (this as any).possibleRulesFor(action, this._anySubjectType));\n    }\n\n    actionRules.rules = rules;\n    actionRules.merged = true;\n\n    return rules;\n  }\n\n  rulesFor(...args: AbilitySubjectTypeParameters<A>): Rule<A, Conditions>[]\n  rulesFor(action: string, subjectType?: SubjectType, field?: string): Rule<A, Conditions>[] {\n    const rules: Rule<A, Conditions>[] = (this as any).possibleRulesFor(action, subjectType);\n\n    if (field && typeof field !== 'string') {\n      throw new Error('The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details');\n    }\n\n    if (!this._hasPerFieldRules) {\n      return rules;\n    }\n\n    return rules.filter(rule => rule.matchesField(field));\n  }\n\n  on<T extends keyof EventsMap<this>>(\n    event: T,\n    handler: EventsMap<Public<this>>[T]\n  ): Unsubscribe {\n    const tail = this._events.get(event) || null;\n    const item = linkedItem(handler, tail);\n    this._events.set(event, item);\n\n    return () => {\n      const currentTail = this._events.get(event);\n\n      if (!item.next && !item.prev && currentTail === item) {\n        this._events.delete(event);\n      } else if (item === currentTail) {\n        this._events.set(event, item.prev);\n      }\n\n      unlinkItem(item);\n    };\n  }\n\n  private _emit<T extends keyof EventsMap<this>>(\n    name: T,\n    payload: Parameters<EventsMap<this>[T]>[0]\n  ) {\n    let current = this._events.get(name) || null;\n    while (current !== null) {\n      const prev = current.prev ? cloneLinkedItem(current.prev) : null;\n      current.value(payload);\n      current = prev;\n    }\n  }\n}\n","import { RuleIndex, RuleIndexOptions, RuleIndexOptionsOf, Public, RawRuleOf } from './RuleIndex';\nimport { Abilities, AbilityTuple, CanParameters, Subject } from './types';\nimport { Rule } from './Rule';\n\nexport interface AbilityOptions<A extends Abilities, Conditions>\n  extends RuleIndexOptions<A, Conditions> {}\nexport interface AnyAbility extends Public<PureAbility<any, any>> {}\nexport interface AbilityOptionsOf<T extends AnyAbility> extends RuleIndexOptionsOf<T> {}\nexport type AbilityClass<T extends AnyAbility> = new (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport class PureAbility<\n  A extends Abilities = AbilityTuple,\n  Conditions = unknown\n> extends RuleIndex<A, Conditions> {\n  can(...args: CanParameters<A>): boolean {\n    const rule = this.relevantRuleFor(...args);\n    return !!rule && !rule.inverted;\n  }\n\n  relevantRuleFor(...args: CanParameters<A>): Rule<A, Conditions> | null\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null {\n    const subjectType = this.detectSubjectType(subject);\n    const rules = (this as any).rulesFor(action, subjectType, field);\n\n    for (let i = 0, length = rules.length; i < length; i++) {\n      if (rules[i].matchesConditions(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  }\n\n  cannot(...args: CanParameters<A>): boolean {\n    return !this.can(...args);\n  }\n}\n","import {\n  $eq,\n  eq,\n  $ne,\n  ne,\n  $lt,\n  lt,\n  $lte,\n  lte,\n  $gt,\n  gt,\n  $gte,\n  gte,\n  $in,\n  within,\n  $nin,\n  nin,\n  $all,\n  all,\n  $size,\n  size,\n  $regex,\n  $options,\n  regex,\n  $elemMatch,\n  elemMatch,\n  $exists,\n  exists,\n  and,\n  createFactory,\n  BuildMongoQuery,\n  DefaultOperators,\n} from '@ucast/mongo2js';\nimport { ConditionsMatcher, AnyObject } from '../types';\nimport { Container, GenericFactory } from '../hkt';\n\nconst defaultInstructions = {\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $options,\n  $elemMatch,\n  $exists,\n};\nconst defaultInterpreters = {\n  eq,\n  ne,\n  lt,\n  lte,\n  gt,\n  gte,\n  in: within,\n  nin,\n  all,\n  size,\n  regex,\n  elemMatch,\n  exists,\n  and,\n};\n\ninterface MongoQueryFactory extends GenericFactory {\n  produce: MongoQuery<this[0]>\n}\n\ntype MergeUnion<T extends {}, Keys extends keyof T = keyof T> = { [K in Keys]: T[K] };\nexport type MongoQuery<T = AnyObject> = BuildMongoQuery<MergeUnion<T>, {\n  toplevel: {},\n  field: Pick<DefaultOperators<MergeUnion<T>>['field'], keyof typeof defaultInstructions>\n}> & Container<MongoQueryFactory>;\n\ntype MongoQueryMatcherFactory =\n  (...args: Partial<Parameters<typeof createFactory>>) => ConditionsMatcher<MongoQuery>;\nexport const buildMongoQueryMatcher = ((instructions, interpreters, options) => createFactory(\n  { ...defaultInstructions, ...instructions },\n  { ...defaultInterpreters, ...interpreters },\n  options\n)) as MongoQueryMatcherFactory;\n\nexport const mongoQueryMatcher = createFactory(defaultInstructions, defaultInterpreters);\nexport type {\n  MongoQueryFieldOperators,\n  MongoQueryTopLevelOperators,\n  MongoQueryOperators,\n} from '@ucast/mongo2js';\n","import { FieldMatcher } from '../types';\n\nconst REGEXP_SPECIAL_CHARS = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst REGEXP_ANY = /\\.?\\*+\\.?/g;\nconst REGEXP_STARS = /\\*+/;\nconst REGEXP_DOT = /\\./g;\n\nfunction detectRegexpPattern(match: string, index: number, string: string): string {\n  const quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.'\n    ? '+'\n    : '*';\n  const matcher = match.indexOf('**') === -1 ? '[^.]' : '.';\n  const pattern = match.replace(REGEXP_DOT, '\\\\$&')\n    .replace(REGEXP_STARS, matcher + quantifier);\n\n  return index + match.length === string.length ? `(?:${pattern})?` : pattern;\n}\n\nfunction escapeRegexp(match: string, index: number, string: string): string {\n  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {\n    return match;\n  }\n\n  return `\\\\${match}`;\n}\n\nfunction createPattern(fields: string[]) {\n  const patterns = fields.map(field => field\n    .replace(REGEXP_SPECIAL_CHARS, escapeRegexp)\n    .replace(REGEXP_ANY, detectRegexpPattern));\n  const pattern = patterns.length > 1 ? `(?:${patterns.join('|')})` : patterns[0];\n\n  return new RegExp(`^${pattern}$`);\n}\n\nexport const fieldPatternMatcher: FieldMatcher = (fields) => {\n  let pattern: RegExp | null;\n\n  return (field) => {\n    if (typeof pattern === 'undefined') {\n      pattern = fields.every(f => f.indexOf('*') === -1)\n        ? null\n        : createPattern(fields);\n    }\n\n    return pattern === null\n      ? fields.indexOf(field) !== -1\n      : pattern.test(field);\n  };\n};\n","import { PureAbility, AbilityOptions } from './PureAbility';\nimport { RawRuleFrom } from './RawRule';\nimport { AbilityTuple } from './types';\nimport { MongoQuery, mongoQueryMatcher } from './matchers/conditions';\nimport { fieldPatternMatcher } from './matchers/field';\nimport { Public } from './RuleIndex';\n\nexport class Ability<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {\n  constructor(rules: RawRuleFrom<A, C>[] = [], options: AbilityOptions<A, C> = {}) {\n    super(rules, {\n      conditionsMatcher: mongoQueryMatcher,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n\nexport interface AnyMongoAbility extends Public<Ability<any, MongoQuery>> {}\n","import { Ability, AnyMongoAbility } from './Ability';\nimport { AnyAbility, AbilityOptionsOf, AbilityClass } from './PureAbility';\nimport { RawRuleOf, Generics } from './RuleIndex';\nimport {\n  ExtractSubjectType as E,\n  AbilityTuple,\n  SubjectType,\n  TaggedInterface,\n  Normalize,\n  AnyObject,\n  AnyClass,\n} from './types';\nimport { ProduceGeneric } from './hkt';\n\nclass RuleBuilder<T extends AnyAbility> {\n  public _rule!: RawRuleOf<T>;\n\n  constructor(rule: RawRuleOf<T>) {\n    this._rule = rule;\n  }\n\n  because(reason: string): this {\n    this._rule.reason = reason;\n    return this;\n  }\n}\n\ntype InstanceOf<T extends AnyAbility, S extends SubjectType> = S extends AnyClass<infer R>\n  ? R\n  : S extends string\n    ? Exclude<Normalize<Generics<T>['abilities']>[1], SubjectType> extends TaggedInterface<string>\n      ? Extract<Normalize<Generics<T>['abilities']>[1], TaggedInterface<S>>\n      : AnyObject\n    : never;\ntype ConditionsOf<T extends AnyAbility, I extends {}> =\n  ProduceGeneric<Generics<T>['conditions'], I>;\ntype ActionFrom<T extends AbilityTuple, S extends SubjectType> = T extends any\n  ? S extends T[1] ? T[0] : never\n  : never;\ntype ActionOf<T extends AnyAbility, S extends SubjectType> = ActionFrom<Generics<T>['abilities'], S>;\ntype SubjectTypeOf<T extends AnyAbility> = E<Normalize<Generics<T>['abilities']>[1]>;\n\ntype SimpleCanParams<T extends AnyAbility> = Parameters<(\n  action: Generics<T>['abilities'] | Generics<T>['abilities'][]\n) => 0>;\ntype BuilderCanParameters<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\n\ntype BuilderCanParametersWithFields<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  F extends string,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    fields?: F | F[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\ntype Keys<T> = string & keyof T;\n\nexport class AbilityBuilder<T extends AnyAbility> {\n  public rules: RawRuleOf<T>[] = [];\n  private _AbilityType!: AnyClass<T>;\n\n  constructor(AbilityType: AnyClass<T>) {\n    this._AbilityType = AbilityType;\n    this.can = this.can.bind(this as any);\n    this.cannot = this.cannot.bind(this as any);\n    this.build = this.build.bind(this as any);\n  }\n\n  can<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  can<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  can(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions']\n  ): RuleBuilder<T> {\n    const rule = { action } as RawRuleOf<T>;\n\n    if (subject) {\n      rule.subject = subject;\n\n      if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n        rule.fields = conditionsOrFields;\n      } else if (typeof conditionsOrFields !== 'undefined') {\n        rule.conditions = conditionsOrFields;\n      }\n\n      if (typeof conditions !== 'undefined') {\n        rule.conditions = conditions;\n      }\n    }\n\n    this.rules.push(rule);\n\n    return new RuleBuilder(rule);\n  }\n\n  cannot<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  cannot<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  cannot(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n  ): RuleBuilder<T> {\n    const builder = (this as any).can(action, subject, conditionsOrFields, conditions);\n    builder._rule.inverted = true;\n    return builder;\n  }\n\n  build(options?: AbilityOptionsOf<T>) {\n    return new this._AbilityType(this.rules, options);\n  }\n}\n\ntype DSL<T extends AnyAbility, R> = (\n  can: AbilityBuilder<T>['can'],\n  cannot: AbilityBuilder<T>['cannot']\n) => R;\n\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, Promise<void>>, options?: AbilityOptionsOf<T>): Promise<T>;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void>, options?: AbilityOptionsOf<T>): T;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void | Promise<void>>, options?: AbilityOptionsOf<T>): T | Promise<T> {\n  const builder = new AbilityBuilder(Ability as unknown as AbilityClass<T>);\n  const result = define(builder.can, builder.cannot);\n\n  if (result && typeof result.then === 'function') {\n    return result.then(() => builder.build(options));\n  }\n\n  return builder.build(options);\n}\n","import { AnyAbility } from './PureAbility';\nimport { Normalize } from './types';\nimport { Generics } from './RuleIndex';\nimport { getSubjectTypeName } from './utils';\n\nexport type GetErrorMessage = (error: ForbiddenError<AnyAbility>) => string;\nexport const getDefaultErrorMessage: GetErrorMessage = error => `Cannot execute \"${error.action}\" on \"${error.subjectType}\"`;\n\nconst NativeError = function NError(this: Error, message: string) {\n  this.message = message;\n} as unknown as new (message: string) => Error;\n\nNativeError.prototype = Object.create(Error.prototype);\n\nexport class ForbiddenError<T extends AnyAbility> extends NativeError {\n  public readonly ability!: T;\n  public action!: Normalize<Generics<T>['abilities']>[0];\n  public subject!: Generics<T>['abilities'][1];\n  public field?: string;\n  public subjectType!: string;\n\n  static _defaultErrorMessage = getDefaultErrorMessage;\n\n  static setDefaultMessage(messageOrFn: string | GetErrorMessage) {\n    this._defaultErrorMessage = typeof messageOrFn === 'string' ? () => messageOrFn : messageOrFn;\n  }\n\n  static from<U extends AnyAbility>(ability: U) {\n    return new this<U>(ability);\n  }\n\n  private constructor(ability: T) {\n    super('');\n    this.ability = ability;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      this.name = 'ForbiddenError';\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  setMessage(message: string) {\n    this.message = message;\n    return this;\n  }\n\n  throwUnlessCan(...args: Parameters<T['can']>) {\n    const rule = this.ability.relevantRuleFor(...args);\n\n    if (rule && !rule.inverted) {\n      return;\n    }\n\n    this.action = args[0];\n    this.subject = args[1];\n    this.subjectType = getSubjectTypeName(this.ability.detectSubjectType(args[1]));\n    this.field = args[2];\n\n    const reason = rule ? rule.reason : '';\n    // eslint-disable-next-line no-underscore-dangle\n    this.message = this.message || reason || (this.constructor as any)._defaultErrorMessage(this);\n    throw this; // eslint-disable-line\n  }\n}\n","import { PureComponent, ReactNode } from 'react';\nimport {\n  Unsubscribe,\n  AbilityTuple,\n  SubjectType,\n  AnyAbility,\n  Generics,\n  Abilities,\n  IfString,\n} from '@casl/ability';\n\nconst noop = () => {};\n\ntype AbilityCanProps<\n  T extends Abilities,\n  Else = IfString<T, { do: T } | { I: T }>\n> = T extends AbilityTuple\n  ? { do: T[0], on: T[1], field?: string } |\n  { I: T[0], a: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], an: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], this: Exclude<T[1], SubjectType>, field?: string }\n  : Else;\n\ninterface ExtraProps {\n  not?: boolean\n  passThrough?: boolean\n}\n\ninterface CanExtraProps<T extends AnyAbility> extends ExtraProps {\n  ability: T\n  children: ReactNode | ((isAllowed: boolean, ability: T) => ReactNode)\n}\n\ninterface BoundCanExtraProps<T extends AnyAbility> extends ExtraProps {\n  ability?: T\n  children: ReactNode | ((isAllowed: boolean, ability: T) => ReactNode)\n}\n\nexport type CanProps<T extends AnyAbility> =\n  AbilityCanProps<Generics<T>['abilities']> & CanExtraProps<T>;\nexport type BoundCanProps<T extends AnyAbility> =\n  AbilityCanProps<Generics<T>['abilities']> & BoundCanExtraProps<T>;\n\nexport class Can<\n  T extends AnyAbility,\n  IsBound extends boolean = false\n> extends PureComponent<IsBound extends true ? BoundCanProps<T> : CanProps<T>> {\n  private _isAllowed: boolean = false;\n  private _ability: T | null = null;\n  private _unsubscribeFromAbility: Unsubscribe = noop;\n\n  componentWillUnmount() {\n    this._unsubscribeFromAbility();\n  }\n\n  private _connectToAbility(ability?: T) {\n    if (ability === this._ability) {\n      return;\n    }\n\n    this._unsubscribeFromAbility();\n    this._ability = null;\n\n    if (ability) {\n      this._ability = ability;\n      this._unsubscribeFromAbility = ability.on('updated', () => this.forceUpdate());\n    }\n  }\n\n  get allowed() {\n    return this._isAllowed;\n  }\n\n  private _canRender(): boolean {\n    const props: any = this.props;\n    const subject = props.of || props.a || props.an || props.this || props.on;\n    const can = props.not ? 'cannot' : 'can';\n\n    return props.ability[can](props.I || props.do, subject, props.field);\n  }\n\n  render() {\n    this._connectToAbility(this.props.ability);\n    this._isAllowed = this._canRender();\n    return this.props.passThrough || this._isAllowed ? this._renderChildren() : null;\n  }\n\n  private _renderChildren() {\n    const { children, ability } = this.props;\n    const elements = typeof children === 'function'\n      ? children(this._isAllowed, ability as any)\n      : children;\n\n    return elements as ReactNode;\n  }\n}\n","import React from 'react';\r\nimport { Row, Col, Button, ButtonGroup, ListGroup, ListGroupItem } from 'reactstrap';\r\nimport { defineAbility } from '@casl/ability';\r\nimport { Can } from '@casl/react';\r\nimport ComponentCard from '../../../components/ComponentCard';\r\n\r\nconst permissions = {\r\n  CanEdit: {\r\n    action: 'Can-edit',\r\n    subject: 'address',\r\n  },\r\n  CanDelete: {\r\n    action: 'Can-delete',\r\n    subject: 'address',\r\n  },\r\n};\r\n\r\nconst users = {\r\n  admin: {\r\n    permissions: ['CanEdit', 'CanDelete'],\r\n  },\r\n  Manager: {\r\n    permissions: ['CanEdit'],\r\n  },\r\n  SubscriberReadOnly: {\r\n    permissions: [],\r\n  },\r\n};\r\n\r\nconst addresses = [\r\n  {\r\n    city: 'New York',\r\n    street: '5684 Max Summit',\r\n    type: 'address',\r\n  },\r\n  {\r\n    city: 'Manhatten York',\r\n    street: '5684 Max Summit',\r\n    type: 'address',\r\n  },\r\n  {\r\n    city: 'Canada street York',\r\n    street: '5684 Max Summit',\r\n    type: 'address',\r\n  },\r\n  {\r\n    city: 'Delhi street',\r\n    street: '5684 Max Summit',\r\n    type: 'address',\r\n  },\r\n  {\r\n    city: 'UP Chawk',\r\n    street: '5684 Max Summit',\r\n    type: 'address',\r\n  },\r\n];\r\n\r\nconst AccessControl = () => {\r\n  const [userId, setUserId] = React.useState(Object.keys(users)[0]);\r\n  const userPermissions = users[userId].permissions.map((id) => permissions[id]);\r\n\r\n  const actions = [\r\n    ...userPermissions.reduce((collection, { action }) => {\r\n      collection.add(action);\r\n      return collection;\r\n    }, new Set()),\r\n  ];\r\n\r\n  const ability = defineAbility((can) => {\r\n    userPermissions.forEach(({ action, subject }) => {\r\n      can(action, subject);\r\n    });\r\n  });\r\n  return (\r\n    <Row>\r\n      <Col lg=\"12\">\r\n        {/* --------------------------------------------------------------------------------*/}\r\n        {/* Card-1*/}\r\n        {/* --------------------------------------------------------------------------------*/}\r\n        <ComponentCard title=\"Roll base Access\">\r\n          <ButtonGroup>\r\n            {Object.entries(users).map(([id]) => (\r\n              <Button\r\n                key={id}\r\n                outline={userId !== id}\r\n                color=\"primary\"\r\n                onClick={() => setUserId(id)}\r\n              >\r\n                {id}\r\n              </Button>\r\n            ))}\r\n          </ButtonGroup>\r\n          <div className=\"p-3 bg-light mt-3\">\r\n            {users[userId].permissions.map((permission) => (\r\n              <div key={permission}>{permission}</div>\r\n            ))}\r\n          </div>\r\n          <ListGroup className=\"mt-4\">\r\n            {addresses.map(({ city, street, type }) => (\r\n              <ListGroupItem key={city}>\r\n                <div>\r\n                  {city}, {street}\r\n                  {actions.map((action) => (\r\n                    <Can I={action} a={type} ability={ability}>\r\n                      <Button className=\"mx-1\" size=\"sm\">\r\n                        {action}\r\n                      </Button>\r\n                    </Can>\r\n                  ))}\r\n                </div>\r\n              </ListGroupItem>\r\n            ))}\r\n          </ListGroup>\r\n        </ComponentCard>\r\n      </Col>\r\n    </Row>\r\n  );\r\n};\r\n\r\nexport default AccessControl;\r\n","import getPrototypeOf from \"./getPrototypeOf.js\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","import superPropBase from \"./superPropBase.js\";\nexport default function _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}"],"names":["children","title","subtitle","tag","className","Condition","constructor","operator","value","Object","defineProperty","this","writable","_notes","addNote","note","push","DocumentCondition","CompoundCondition","conditions","Array","isArray","Error","ITSELF","FieldCondition","field","NULL_CONDITION","hasOwnProperty","prototype","call","bind","isCompound","condition","optimizedCompoundCondition","length","flattenConditions","aggregatedResult","flatConditions","i","currentNode","identity","x","object","create","ignoreValue","hasOperators","instructions","skipIgnore","prop","objectKeysSkipIgnore","anyObject","keys","key","pushIfNonNullCondition","buildAnd","defaultInstructionParsers","compound","instruction","context","map","query","parse","name","document","ObjectQueryParser","options","_instructions","_fieldInstructionContext","_documentInstructionContext","_options","_objectKeys","operatorToConditionName","defaultOperatorName","mergeFinalConditions","reduce","all","fieldContext","useIgnoreValue","documentContext","setParse","parseField","parentQuery","type","parseInstruction","validate","parseFieldOperators","op","getInterpreter","interpreters","interpret","defaultInterpreterName","createInterpreter","rawOptions","getInterpreterName","numberOfArguments","interpreterName","defaultContext","params","translate","ensureIsArray","ensureIsNonEmptyArray","ensureIs","$and","queries","$or","$nor","$not","RegExp","$elemMatch","$size","$in","$nin","$all","$mod","$exists","$gte","Date","$gt","$lt","$lte","$eq","$ne","$regex","rawValue","$options","$where","__proto__","MongoQueryParser","slice","and","allParsingInstructions","includes","items","compare","isArrayAndNotNumericField","Number","isNaN","getField","get","result","concat","testValueOrArray","test","node","some","v","defaultGet","getObjectFieldCursor","path","dotIndex","lastIndexOf","getObjectField","String","indexOf","paths","split","a","b","createJsInterpreter","operators","or","every","eq","ne","lte","lt","gt","gte","exists","item","mod","size","regex","within","nin","elemMatch","allInterpreters","in","toPrimitive","getTime","toJSON","comparePrimitives","createFactory","parser","forPrimitives","args","ast","createTranslatorFactory","defaultParsers","wrapArray","TYPE_FIELD","isSubjectType","getSubjectClassName","modelName","getSubjectTypeName","detectSubjectType","subject","copyArrayTo","dest","target","start","mergePrioritized","array","anotherArray","j","merged","priority","getOrDefault","defaultValue","set","rule","fields","fieldMatcher","conditionsMatcher","Rule","action","resolveAction","inverted","reason","undefined","_conditionsMatcher","_matchConditions","matches","matchesConditions","matchesField","_matchField","cloneLinkedItem","prev","next","defaultActionEntry","rules","defaultSubjectEntry","Map","analyze","index","_hasPerFieldRules","RuleIndex","_events","_ruleOptions","_anyAction","anyAction","_anySubjectType","anySubjectType","_detectSubjectType","_rules","_indexedRules","_buildIndexFor","update","event","ability","_emit","rawRules","indexedRules","actions","subjects","k","subjectRules","possibleRulesFor","subjectType","actionRules","anyActionRules","has","rulesFor","filter","on","handler","linkedItem","tail","currentTail","delete","unlinkItem","payload","current","PureAbility","can","relevantRuleFor","cannot","defaultInstructions","defaultInterpreters","mongoQueryMatcher","REGEXP_SPECIAL_CHARS","REGEXP_ANY","REGEXP_STARS","REGEXP_DOT","detectRegexpPattern","match","string","quantifier","matcher","pattern","replace","escapeRegexp","fieldPatternMatcher","f","patterns","join","createPattern","Ability","RuleBuilder","_rule","because","AbilityBuilder","AbilityType","_AbilityType","build","conditionsOrFields","builder","NativeError","message","ForbiddenError","captureStackTrace","setMessage","throwUnlessCan","_defaultErrorMessage","messageOrFn","error","getDefaultErrorMessage","noop","Can","PureComponent","_isAllowed","_ability","_unsubscribeFromAbility","componentWillUnmount","_connectToAbility","forceUpdate","_canRender","props","of","an","not","I","do","render","passThrough","_renderChildren","permissions","CanEdit","CanDelete","users","admin","Manager","SubscriberReadOnly","addresses","city","street","React","userId","setUserId","userPermissions","id","collection","add","Set","define","then","defineAbility","forEach","lg","ComponentCard","entries","outline","color","onClick","permission","_superPropBase","property","getPrototypeOf","_get","Reflect","receiver","base","desc","getOwnPropertyDescriptor","arguments","apply"],"sourceRoot":""}